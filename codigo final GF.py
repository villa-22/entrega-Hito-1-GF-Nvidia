# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FwMiX6EoHRHVhdxLwt6pJRX9xTubzwpv
"""

import pandas as pd

# Leer los datos del archivo CSV
data = pd.read_csv('/content/NVDA Historical Data (2).csv')

# Ver las primeras filas de datos
data.head()

# Convertir la columna 'Date' a formato datetime
data['Date'] = pd.to_datetime(data['Date'], format='%m/%d/%Y')

# Ordenar los datos por fecha
data = data.sort_values('Date')

# Convertir la columna 'Price' a numérico
data['Price'] = pd.to_numeric(data['Price'], errors='coerce')

# Calcular rendimientos diarios
data['Returns'] = data['Price'].pct_change().dropna()

# Ver los rendimientos diarios calculados
data[['Date', 'Price', 'Returns']].head()

# Calcular la volatilidad histórica (anualizada)
volatility = data['Returns'].std() * (252 ** 0.5)  # 252 días en un año
print(f'Volatilidad histórica anualizada: {volatility:.2%}')

import numpy as np
from scipy.stats import norm

# Parámetros para el modelo Black-Scholes
S0 = data['Price'].iloc[-1]  # Precio actual de la acción
X = 35  # Precio de ejercicio
T = 0.5  # Tiempo hasta el vencimiento (6 meses)
r = 0.02  # Tasa de interés libre de riesgo (2% anual)
sigma = volatility  # Volatilidad histórica

# Calcular d1 y d2
d1 = (np.log(S0 / X) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
d2 = d1 - sigma * np.sqrt(T)

# Valor de la opción call
C = S0 * norm.cdf(d1) - X * np.exp(-r * T) * norm.cdf(d2)
print(f'Valor de la opción call: {C:.2f}')

# Definir parámetros del árbol binomial
N = 100  # Número de pasos
dt = T / N  # Incremento de tiempo por paso
u = np.exp(sigma * np.sqrt(dt))  # Factor de subida
d = 1 / u  # Factor de bajada
p = (np.exp(r * dt) - d) / (u - d)  # Probabilidad neutra al riesgo

# Inicializar precios y valores del árbol binomial
price_tree = np.zeros((N + 1, N + 1))
price_tree[0, 0] = S0

# Construir el árbol de precios
for i in range(1, N + 1):
    for j in range(i + 1):
        price_tree[j, i] = S0 * (u ** (i - j)) * (d ** j)

# Calcular el valor de la opción en los nodos finales
option_tree = np.zeros((N + 1, N + 1))
option_tree[:, N] = np.maximum(0, price_tree[:, N] - X)

# Retroceder en el árbol para obtener el valor de la opción hoy
for i in range(N - 1, -1, -1):
    for j in range(i + 1):
        option_tree[j, i] = np.exp(-r * dt) * (p * option_tree[j, i + 1] + (1 - p) * option_tree[j + 1, i + 1])

# Valor de la opción call
option_value_binomial = option_tree[0, 0]
print(f'Valor de la opción call (Árbol Binomial): {option_value_binomial:.2f}')

# Parámetros para la simulación
num_simulations = 10000
num_days = int(T * 252)  # Número de días en el horizonte de tiempo

# Matriz para almacenar los precios simulados
simulated_prices = np.zeros((num_simulations, num_days))
simulated_prices[:, 0] = S0

# Simulación de Monte Carlo
for i in range(1, num_days):
    random_returns = np.random.normal(r / 252, sigma / np.sqrt(252), num_simulations)
    simulated_prices[:, i] = simulated_prices[:, i - 1] * (1 + random_returns)

# Calcular el payoff promedio de la opción
payoffs = np.maximum(simulated_prices[:, -1] - X, 0)
option_value_mc = np.exp(-r * T) * np.mean(payoffs)
print(f'Valor estimado de la opción call (Monte Carlo): {option_value_mc:.2f}')

"""#Valor de la opción call (Modelo Black-Scholes): 67.15 USD
#Valor de la opción call (Modelo Árbol Binomial): 67.15 USD
#Volatilidad histórica anualizada: 53.48%
Conclusión:
Ambos modelos (Black-Scholes y Árbol Binomial) han arrojado resultados prácticamente idénticos en cuanto al valor de la opción call. Esto indica que ambos métodos proporcionan una estimación consistente del valor teórico de la opción, teniendo en cuenta la volatilidad histórica elevada de Nvidia, que es del 53.48%.

Este nivel de volatilidad refleja que las acciones de Nvidia han experimentado fluctuaciones significativas en el mercado durante el período analizado, lo cual se traduce en un mayor valor para la opción, ya que mayor volatilidad tiende a aumentar el valor de las opciones debido a las mayores posibilidades de que el precio de la acción alcance el precio de ejercicio en el futuro.
"""

import numpy as np

# Parámetros para el modelo binomial
S0 = 101.79  # Precio actual de la acción
X = 35       # Precio de ejercicio
T = 0.5      # Tiempo hasta el vencimiento en años
r = 0.02     # Tasa de interés libre de riesgo (2%)
sigma = 0.5348  # Volatilidad histórica anualizada (53.48%)
N = 100      # Número de pasos en el modelo binomial

# Calcular parámetros del árbol binomial
dt = T / N  # Paso de tiempo
u = np.exp(sigma * np.sqrt(dt))  # Factor de subida
d = 1 / u  # Factor de bajada
p = (np.exp(r * dt) - d) / (u - d)  # Probabilidad ajustada al riesgo

# Crear el árbol de precios de la acción
price_tree = np.zeros((N + 1, N + 1))
price_tree[0, 0] = S0

for i in range(1, N + 1):
    for j in range(i + 1):
        price_tree[j, i] = S0 * (u ** (i - j)) * (d ** j)

# Crear el árbol de valor de la opción call
option_tree = np.zeros((N + 1, N + 1))
option_tree[:, N] = np.maximum(0, price_tree[:, N] - X)

# Retroceder para calcular el valor de la opción en el nodo inicial
for i in range(N - 1, -1, -1):
    for j in range(i + 1):
        option_tree[j, i] = np.exp(-r * dt) * (p * option_tree[j, i + 1] + (1 - p) * option_tree[j + 1, i + 1])

# Valor de la opción en el tiempo presente
valor_opcion_binomial = option_tree[0, 0]
print(f"Valor de la opción call con el modelo binomial: {valor_opcion_binomial:.2f} USD")

# Simulación de precios futuros utilizando Monte Carlo para modelar los retornos
num_simulaciones = 10000
num_dias = int(T * 252)  # Número de días en el horizonte temporal

# Inicializar la matriz de precios simulados
precios_simulados = np.zeros((num_simulaciones, num_dias))
precios_simulados[:, 0] = S0

# Simular precios basados en volatilidad y tasa de interés
for i in range(1, num_dias):
    rendimientos = np.random.normal(r / 252, sigma / np.sqrt(252), num_simulaciones)
    precios_simulados[:, i] = precios_simulados[:, i - 1] * (1 + rendimientos)

# Valor de la opción put para cada simulación
payoffs_put = np.maximum(X - precios_simulados[:, -1], 0)
valor_put_montecarlo = np.exp(-r * T) * np.mean(payoffs_put)
print(f"Valor de la opción put simulada: {valor_put_montecarlo:.2f} USD")